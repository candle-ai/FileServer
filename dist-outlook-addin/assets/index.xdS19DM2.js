var R=Object.defineProperty;var x=(n,e,r)=>e in n?R(n,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):n[e]=r;var a=(n,e,r)=>x(n,typeof e!="symbol"?e+"":e,r);import{A as O,L as T,a as _,b as M,C as N,I as D}from"./taskpane.js";import"./modulepreload-polyfill.B5Qt9EMX.js";class ${constructor(e){a(this,"logger");a(this,"changeListeners",new Set);var r;this.logger=e,(r=chrome==null?void 0:chrome.storage)!=null&&r.onChanged&&chrome.storage.onChanged.addListener(this.handleStorageChange.bind(this))}async getSessionItem(e){try{const r=await new Promise((o,t)=>{chrome.storage.session.get(e,s=>{chrome.runtime.lastError?t(new Error(chrome.runtime.lastError.message)):o(s)})});if(r[e]!==void 0){const o=JSON.parse(r[e]);return this.logger.debug(`Retrieved session item with key: ${e}`,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"getSessionItem"}),o}return null}catch(r){return this.logger.error(`Error retrieving session item with key: ${e}`,r,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"getSessionItem"}),null}}async setSessionItem(e,r){try{const o={[e]:JSON.stringify(r)};await new Promise((t,s)=>{chrome.storage.session.set(o,()=>{chrome.runtime.lastError?s(new Error(chrome.runtime.lastError.message)):t()})}),this.logger.debug(`Stored session item with key: ${e}`,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"setSessionItem"})}catch(o){throw this.logger.error(`Error storing session item with key: ${e}`,o,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"setSessionItem"}),o}}async removeSessionItem(e){try{await new Promise((r,o)=>{chrome.storage.session.remove(e,()=>{chrome.runtime.lastError?o(new Error(chrome.runtime.lastError.message)):r()})}),this.logger.debug(`Removed session item with key: ${e}`,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"removeSessionItem"})}catch(r){throw this.logger.error(`Error removing session item with key: ${e}`,r,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"removeSessionItem"}),r}}async clearSession(){try{await new Promise((e,r)=>{chrome.storage.session.clear(()=>{chrome.runtime.lastError?r(new Error(chrome.runtime.lastError.message)):e()})}),this.logger.info("Cleared session storage",{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"clearSession"})}catch(e){throw this.logger.error("Error clearing session storage",e,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"clearSession"}),e}}async getLocalItem(e){try{const r=await new Promise((o,t)=>{chrome.storage.local.get(e,s=>{chrome.runtime.lastError?t(new Error(chrome.runtime.lastError.message)):o(s)})});if(r[e]!==void 0){const o=JSON.parse(r[e]);return this.logger.debug(`Retrieved local item with key: ${e}`,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"getLocalItem"}),o}return null}catch(r){return this.logger.error(`Error retrieving local item with key: ${e}`,r,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"getLocalItem"}),null}}async setLocalItem(e,r){try{const o={[e]:JSON.stringify(r)};await new Promise((t,s)=>{chrome.storage.local.set(o,()=>{chrome.runtime.lastError?s(new Error(chrome.runtime.lastError.message)):t()})}),this.logger.debug(`Stored local item with key: ${e}`,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"setLocalItem"})}catch(o){throw this.logger.error(`Error storing local item with key: ${e}`,o,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"setLocalItem"}),o}}async removeLocalItem(e){try{await new Promise((r,o)=>{chrome.storage.local.remove(e,()=>{chrome.runtime.lastError?o(new Error(chrome.runtime.lastError.message)):r()})}),this.logger.debug(`Removed local item with key: ${e}`,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"removeLocalItem"})}catch(r){throw this.logger.error(`Error removing local item with key: ${e}`,r,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"removeLocalItem"}),r}}async clearLocal(){try{await new Promise((e,r)=>{chrome.storage.local.clear(()=>{chrome.runtime.lastError?r(new Error(chrome.runtime.lastError.message)):e()})}),this.logger.info("Cleared local storage",{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"clearLocal"})}catch(e){throw this.logger.error("Error clearing local storage",e,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"clearLocal"}),e}}async getSyncItem(e){try{const r=await new Promise((o,t)=>{chrome.storage.sync.get(e,s=>{chrome.runtime.lastError?t(new Error(chrome.runtime.lastError.message)):o(s)})});if(r[e]!==void 0){const o=JSON.parse(r[e]);return this.logger.debug(`Retrieved sync item with key: ${e}`,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"getSyncItem"}),o}return null}catch(r){return this.logger.error(`Error retrieving sync item with key: ${e}`,r,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"getSyncItem"}),null}}async setSyncItem(e,r){try{const o={[e]:JSON.stringify(r)};await new Promise((t,s)=>{chrome.storage.sync.set(o,()=>{chrome.runtime.lastError?s(new Error(chrome.runtime.lastError.message)):t()})}),this.logger.debug(`Stored sync item with key: ${e}`,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"setSyncItem"})}catch(o){throw this.logger.error(`Error storing sync item with key: ${e}`,o,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"setSyncItem"}),o}}async removeSyncItem(e){try{await new Promise((r,o)=>{chrome.storage.sync.remove(e,()=>{chrome.runtime.lastError?o(new Error(chrome.runtime.lastError.message)):r()})}),this.logger.debug(`Removed sync item with key: ${e}`,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"removeSyncItem"})}catch(r){throw this.logger.error(`Error removing sync item with key: ${e}`,r,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"removeSyncItem"}),r}}async clearSync(){try{await new Promise((e,r)=>{chrome.storage.sync.clear(()=>{chrome.runtime.lastError?r(new Error(chrome.runtime.lastError.message)):e()})}),this.logger.info("Cleared sync storage",{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"clearSync"})}catch(e){throw this.logger.error("Error clearing sync storage",e,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"clearSync"}),e}}async setItem(e,r){return this.setLocalItem(e,r)}async getItem(e){return this.getLocalItem(e)}async removeItem(e){return this.removeLocalItem(e)}async clear(){return this.clearLocal()}async getAllKeys(){try{const e=await new Promise((o,t)=>{chrome.storage.local.get(null,s=>{chrome.runtime.lastError?t(new Error(chrome.runtime.lastError.message)):o(s)})}),r=Object.keys(e);return this.logger.debug(`Retrieved ${r.length} keys from storage`,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"getAllKeys"}),r}catch(e){return this.logger.error("Error getting all keys",e,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"getAllKeys"}),[]}}onChanged(e){this.changeListeners.add(e)}removeChangeListener(e){this.changeListeners.delete(e)}handleStorageChange(e,r){if((r==="local"||r==="session"||r==="sync")&&this.changeListeners.size>0){const o={};for(const[t,s]of Object.entries(e))try{o[t]={oldValue:s.oldValue?JSON.parse(s.oldValue):void 0,newValue:s.newValue?JSON.parse(s.newValue):void 0}}catch(i){this.logger.warn("Error parsing storage change values",{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"handleStorageChange",key:t,error:i}),o[t]={oldValue:s.oldValue,newValue:s.newValue}}this.changeListeners.forEach(t=>{try{t(o)}catch(s){this.logger.error("Error in storage change callback",s,{sourceFile:"src/platforms/chrome/ChromeStorageProvider.ts",sourceFunction:"handleStorageChange"})}})}}}class U{constructor(e){a(this,"logger");a(this,"threadListeners",new Set);a(this,"currentThread",null);this.logger=e,this.initializeStorageListeners()}initializeStorageListeners(){var e,r;(r=(e=chrome==null?void 0:chrome.storage)==null?void 0:e.session)!=null&&r.onChanged&&chrome.storage.session.onChanged.addListener(o=>{(o.threadId||o.threadData)&&this.handleThreadDataChange()})}async handleThreadDataChange(){var e;try{const r=await this.getCurrentThread();(r==null?void 0:r.threadId)!==((e=this.currentThread)==null?void 0:e.threadId)&&(this.currentThread=r,this.notifyThreadListeners(r))}catch(r){this.logger.error("Error handling thread data change",r,{sourceFile:"src/platforms/chrome/ChromeDataProvider.ts",sourceFunction:"handleThreadDataChange"})}}async getCurrentThread(){return new Promise(e=>{chrome.storage.session.get(["threadId","threadData"],r=>{if(chrome.runtime.lastError){this.logger.error("Error getting thread data",chrome.runtime.lastError,{sourceFile:"src/platforms/chrome/ChromeDataProvider.ts",sourceFunction:"getCurrentThread"}),e(null);return}if(!r.threadId||!r.threadData){e(null);return}try{const o=this.transformToEmailThread(r.threadId,r.threadData);e(o)}catch(o){this.logger.error("Error transforming thread data",o,{sourceFile:"src/platforms/chrome/ChromeDataProvider.ts",sourceFunction:"getCurrentThread"}),e(null)}})})}async getCurrentThreadId(){return new Promise(e=>{chrome.storage.session.get(["threadId"],r=>{if(chrome.runtime.lastError){this.logger.error("Error getting thread ID",chrome.runtime.lastError,{sourceFile:"src/platforms/chrome/ChromeDataProvider.ts",sourceFunction:"getCurrentThreadId"}),e(null);return}e(r.threadId||null)})})}onThreadChanged(e){this.threadListeners.add(e)}removeThreadListener(e){this.threadListeners.delete(e)}notifyThreadListeners(e){this.threadListeners.forEach(r=>{try{r(e)}catch(o){this.logger.error("Error in thread change callback",o,{sourceFile:"src/platforms/chrome/ChromeDataProvider.ts",sourceFunction:"notifyThreadListeners"})}})}transformToEmailThread(e,r){var o;if(!r||!Array.isArray(r))return this.logger.warn("Invalid thread data format",{sourceFile:"src/platforms/chrome/ChromeDataProvider.ts",sourceFunction:"transformToEmailThread",threadId:e,threadData:r}),null;try{const t=r.map(i=>({from:i.from||"Unknown",timestamp:i.timestamp||new Date().toISOString(),subject:i.subject||"No Subject",body:i.body||"",html:i.html||i.body||""})),s=new Set;return r.forEach(i=>{i.from&&typeof i.from=="string"&&s.add(i.from),i.to&&Array.isArray(i.to)&&i.to.forEach(c=>{typeof c=="string"&&s.add(c)}),i.cc&&Array.isArray(i.cc)&&i.cc.forEach(c=>{typeof c=="string"&&s.add(c)}),i.bcc&&Array.isArray(i.bcc)&&i.bcc.forEach(c=>{typeof c=="string"&&s.add(c)})}),{threadId:e,messages:t,subject:((o=t[0])==null?void 0:o.subject)||"No Subject",participants:Array.from(s)}}catch(t){return this.logger.error("Error transforming email messages",t,{sourceFile:"src/platforms/chrome/ChromeDataProvider.ts",sourceFunction:"transformToEmailThread",threadId:e,threadData:r}),null}}}const B="CandleLogsDB",z=1,v="logs";let C=null;function q(){return C||(C=new Promise((n,e)=>{console.log("[Logger] Initializing IndexedDB...");const r=indexedDB.open(B,z);r.onupgradeneeded=o=>{console.log("[Logger] IndexedDB upgrade needed.");const t=o.target.result;if(!t.objectStoreNames.contains(v)){console.log(`[Logger] Creating object store: ${v}`);const s=t.createObjectStore(v,{keyPath:"id",autoIncrement:!0});console.log("[Logger] Creating indexes: timestamp, level, chromeContext"),s.createIndex("timestamp","timestamp",{unique:!1}),s.createIndex("level","level",{unique:!1}),s.createIndex("chromeContext","chromeContext",{unique:!1})}},r.onsuccess=o=>{console.log("[Logger] IndexedDB initialized successfully."),n(o.target.result)},r.onerror=o=>{console.error("[Logger] IndexedDB initialization failed:",o.target.error),C=null,e(o.target.error)},r.onblocked=()=>{console.warn("[Logger] IndexedDB initialization blocked. Close other tabs using the database.")}}),C)}q().catch(n=>console.error("[Logger] Initial DB connection failed:",n));const G=n=>n!==null&&typeof n=="object"&&!Array.isArray(n),W=n=>G(n)?["id_token","access_token","refresh_token","expires_in","token_type"].every(r=>{switch(r){case"expires_in":return typeof n[r]=="number";default:return typeof n[r]=="string"}}):!1,p="src/platforms/helpers/chromeAuthUtils.ts",I=n=>new Promise(e=>{chrome.storage.local.set({token:JSON.stringify(n)},()=>{e()})}),V=()=>new Promise(n=>{chrome.storage.local.get("token",e=>{const r=e.token?JSON.parse(e.token):null;n(r)})}),J=()=>new Promise(n=>{chrome.storage.local.set({token:null},()=>{n()})});async function K(n,e,r){const o="refreshAuthToken",t=new N({region:"us-east-1"});try{r.info("Preparing for REFRESH_TOKEN_AUTH",{sourceFile:p,functionName:o}),r.debug("AuthFlow: REFRESH_TOKEN_AUTH",{sourceFile:p,functionName:o}),r.info("Refreshing auth token...",{sourceFile:p,functionName:o});const s=new D({ClientId:_,AuthFlow:"REFRESH_TOKEN_AUTH",AuthParameters:{REFRESH_TOKEN:n.refresh_token}}),c=(await t.send(s)).AuthenticationResult;if(!c)throw new Error("AuthenticationResult is missing in the response.");const{IdToken:m,AccessToken:h,RefreshToken:d,ExpiresIn:l,TokenType:u}=c;if(!m||!h||!l||!u)throw new Error("Missing required fields in AuthenticationResult.");const f={id_token:m,access_token:h,refresh_token:d||n.refresh_token,expires_in:l,token_type:u,fetched_at:e};return await I(f),f}catch(s){throw r.error("Error refreshing auth token",s,{sourceFile:p,functionName:o}),new Error("Failed to refresh authentication token.")}}async function j(n){const e="handleLoginFlow";try{n.info("Starting OAuth flow in popup...",{sourceFile:p,functionName:e});const r=O(T);n.info("Auth URL",{sourceFile:p,functionName:e,authUrl:r});const o=await chrome.identity.launchWebAuthFlow({url:r,interactive:!0});if(!o)throw new Error("Authentication was cancelled or failed");const s=new URL(o).searchParams.get("code");if(!s)throw new Error("No authorization code received");const i={grant_type:"authorization_code",code:s,redirect_uri:T,client_id:_},c=await fetch(M,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams(i).toString()});if(!c.ok)throw new Error(`Token exchange failed: ${c.statusText}`);const m=await c.json();if(!W(m))throw new Error("Invalid token response format");const h={...m,fetched_at:Math.floor(Date.now()/1e3)};return await I(h),{success:!0}}catch(r){return n.error("Authentication failed",r,{sourceFile:p,functionName:e}),{success:!1,error:r instanceof Error?r.message:"Unknown error occurred"}}}class H{constructor(e){a(this,"logger");a(this,"authListeners",new Set);this.logger=e}async login(){try{const e=await j(this.logger);if(!e.success)throw new Error(e.error||"Login failed");const r=await this.getToken();if(!r)throw new Error("Token not found after login");return this.notifyAuthListeners(!0),r}catch(e){throw this.logger.error("Login failed",e,{sourceFile:"src/platforms/chrome/ChromeAuthProvider.ts",sourceFunction:"login"}),e}}async logout(){var e;try{if(await this.deleteToken(),this.notifyAuthListeners(!1),(e=chrome==null?void 0:chrome.runtime)!=null&&e.sendMessage)try{await chrome.runtime.sendMessage({type:"USER_LOGGED_OUT"})}catch(r){this.logger.warn("Could not send logout message",{sourceFile:"src/platforms/chrome/ChromeAuthProvider.ts",sourceFunction:"logout",error:r})}}catch(r){throw this.logger.error("Logout failed",r,{sourceFile:"src/platforms/chrome/ChromeAuthProvider.ts",sourceFunction:"logout"}),r}}async getToken(){try{return await V()}catch(e){return this.logger.error("Error getting auth token",e,{sourceFile:"src/platforms/chrome/ChromeAuthProvider.ts",sourceFunction:"getToken"}),null}}async saveToken(e){try{const r={...e,fetched_at:Math.floor(Date.now()/1e3)};await I(r)}catch(r){throw this.logger.error("Error saving auth token",r,{sourceFile:"src/platforms/chrome/ChromeAuthProvider.ts",sourceFunction:"saveToken"}),r}}async deleteToken(){try{await J()}catch(e){throw this.logger.error("Error deleting auth token",e,{sourceFile:"src/platforms/chrome/ChromeAuthProvider.ts",sourceFunction:"deleteToken"}),e}}isTokenValid(e){if(!e||!e.expires_in)return!1;const r=e;return r.fetched_at?Math.floor(Date.now()/1e3)-r.fetched_at<r.expires_in:!1}async refreshToken(e){try{const r=e,o=Math.floor(Date.now()/1e3);return await K(r,o,this.logger)}catch(r){throw this.logger.error("Error refreshing auth token",r,{sourceFile:"src/platforms/chrome/ChromeAuthProvider.ts",sourceFunction:"refreshToken"}),r}}async isAuthenticated(){try{const e=await this.getToken();return e!==null&&this.isTokenValid(e)}catch(e){return this.logger.error("Error checking authentication status",e,{sourceFile:"src/platforms/chrome/ChromeAuthProvider.ts",sourceFunction:"isAuthenticated"}),!1}}onAuthStateChanged(e){this.authListeners.add(e)}removeAuthStateListener(e){this.authListeners.delete(e)}notifyAuthListeners(e){this.authListeners.forEach(r=>{try{r(e)}catch(o){this.logger.error("Error in auth state callback",o,{sourceFile:"src/platforms/chrome/ChromeAuthProvider.ts",sourceFunction:"notifyAuthListeners"})}})}}class X{constructor(e){a(this,"logger");a(this,"messageListeners",new Set);this.logger=e,this.setupMessageListeners()}setupMessageListeners(){var e;(e=chrome==null?void 0:chrome.runtime)!=null&&e.onMessage&&chrome.runtime.onMessage.addListener((r,o,t)=>{this.messageListeners.forEach(s=>{try{s(r)}catch(i){this.logger.error("Error in message callback",i,{sourceFile:"src/platforms/chrome/ChromeMessagingProvider.ts",sourceFunction:"setupMessageListeners"})}})})}async sendMessage(e){return new Promise((r,o)=>{var t;if(!((t=chrome==null?void 0:chrome.runtime)!=null&&t.sendMessage)){o(new Error("Chrome runtime not available"));return}chrome.runtime.sendMessage(e,s=>{chrome.runtime.lastError?(this.logger.error("Error sending message",chrome.runtime.lastError,{sourceFile:"src/platforms/chrome/ChromeMessagingProvider.ts",sourceFunction:"sendMessage"}),o(new Error(chrome.runtime.lastError.message))):r(s)})})}onMessage(e){var o;const r=t=>{e(t)};this.messageListeners.add(r),(o=chrome==null?void 0:chrome.runtime)!=null&&o.onMessage&&chrome.runtime.onMessage.addListener(r)}removeMessageListener(e){this.messageListeners.forEach(r=>{var o;(o=chrome==null?void 0:chrome.runtime)!=null&&o.onMessage&&chrome.runtime.onMessage.removeListener(r)}),this.messageListeners.clear()}async sendTabMessage(e,r){return new Promise((o,t)=>{var s;if(!((s=chrome==null?void 0:chrome.tabs)!=null&&s.sendMessage)){t(new Error("Chrome tabs API not available"));return}chrome.tabs.sendMessage(e,r,i=>{chrome.runtime.lastError?(this.logger.error("Error sending tab message",chrome.runtime.lastError,{sourceFile:"src/platforms/chrome/ChromeMessagingProvider.ts",sourceFunction:"sendTabMessage"}),t(new Error(chrome.runtime.lastError.message))):o(i)})})}}class Q{constructor(e){a(this,"logger");a(this,"eventListeners",new Map);a(this,"isInitialized",!1);this.logger=e}async initialize(){if(this.isInitialized){this.logger.info("Chrome platform already initialized",{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"initialize"});return}try{this.logger.info("Initializing Chrome platform...",{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"initialize"}),this.setupChromeEventListeners(),this.isInitialized=!0,this.logger.info("Chrome platform initialized successfully",{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"initialize"})}catch(e){throw this.logger.error("Failed to initialize Chrome platform",e,{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"initialize"}),e}}async cleanup(){try{this.logger.info("Cleaning up Chrome platform...",{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"cleanup"}),this.eventListeners.clear(),this.isInitialized=!1,this.logger.info("Chrome platform cleanup completed",{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"cleanup"})}catch(e){throw this.logger.error("Failed to cleanup Chrome platform",e,{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"cleanup"}),e}}async closeWindow(){try{typeof chrome<"u"&&chrome.sidePanel&&window.close(),this.logger.debug("Window close requested",{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"closeWindow"})}catch(e){throw this.logger.error("Failed to close window",e,{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"closeWindow"}),e}}onPlatformEvent(e,r){var o,t;switch(e){case"runtime.onInstalled":(o=chrome==null?void 0:chrome.runtime)!=null&&o.onInstalled&&chrome.runtime.onInstalled.addListener(r);break;case"runtime.onStartup":(t=chrome==null?void 0:chrome.runtime)!=null&&t.onStartup&&chrome.runtime.onStartup.addListener(r);break;default:this.logger.warn("Unknown platform event",{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"onPlatformEvent",event:e})}}setupChromeEventListeners(){var e,r,o;(e=chrome==null?void 0:chrome.runtime)!=null&&e.onStartup&&chrome.runtime.onStartup.addListener(()=>{this.emitPlatformEvent("startup")}),(r=chrome==null?void 0:chrome.runtime)!=null&&r.onSuspend&&chrome.runtime.onSuspend.addListener(()=>{this.emitPlatformEvent("suspend")}),(o=chrome==null?void 0:chrome.runtime)!=null&&o.onInstalled&&chrome.runtime.onInstalled.addListener(t=>{this.emitPlatformEvent("installed",t)})}emitPlatformEvent(e,...r){const o=this.eventListeners.get(e);o&&o.forEach(t=>{try{t(...r)}catch(s){this.logger.error(`Error in platform event callback for ${e}`,s,{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"emitPlatformEvent",event:e})}})}handleExtensionMessage(e,r,o){return this.logger.debug("Extension message received",{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"handleExtensionMessage",message:e,sender:r}),!0}handleContextMenuClick(e,r){this.logger.debug("Context menu clicked",{sourceFile:"src/platforms/chrome/ChromeLifecycleProvider.ts",sourceFunction:"handleContextMenuClick",info:e,tab:r})}}class Y{constructor(e){a(this,"logger");this.logger=e}getResourceURL(e){return chrome.runtime.getURL(e)}async queryTabs(e={}){return new Promise(r=>{chrome.tabs.query(e,o=>{r(o.map(t=>({id:t.id,url:t.url,active:t.active})))})})}async updateTab(e,r){return new Promise(o=>{chrome.tabs.update(e,r,()=>{o()})})}async reloadTab(e){return new Promise(r=>{chrome.tabs.reload(e,void 0,()=>{r()})})}async openOptionsPage(){return new Promise(e=>{chrome.runtime.openOptionsPage?chrome.runtime.openOptionsPage(()=>{e()}):(window.open("options.html","_blank"),e())})}async openURL(e,r="_blank"){return new Promise(o=>{r==="_blank"?chrome.tabs.create({url:e},()=>{o()}):(window.open(e,r),o())})}}class Z{constructor(e){a(this,"logger");this.logger=e}async executeScript(e){var r;try{return(r=(await chrome.scripting.executeScript({target:e.target,func:e.func,args:e.args}))[0])==null?void 0:r.result}catch(o){throw this.logger.error("Error executing script",o,{sourceFile:"src/platforms/chrome/ChromeContentScriptProvider.ts",sourceFunction:"executeScript"}),o}}async insertContentIntoComposeBox(e){try{const o=(await chrome.tabs.query({active:!0,currentWindow:!0}))[0];if(!(o!=null&&o.id))throw new Error("No active tab found or tab ID is undefined");await chrome.scripting.executeScript({target:{tabId:o.id},func:t=>{function s(){return document.querySelector('div[role="textbox"][aria-label="Message Body"]')||document.querySelector('div[aria-label="Message body, press Alt+F10 to exit"]')}function i(m,h){document.execCommand("insertHTML",!1,h)}const c=s();if(!c)throw new Error("Compose box not found");try{c.focus(),navigator.clipboard&&navigator.clipboard.writeText?navigator.clipboard.writeText(t).then(()=>{document.execCommand("paste")}).catch(()=>{i(c,t)}):i(c,t)}catch(m){throw new Error("Error during paste operation: "+m)}},args:[e]})}catch(r){throw this.logger.error("Error inserting content into compose box",r,{sourceFile:"src/platforms/chrome/ChromeContentScriptProvider.ts",sourceFunction:"insertContentIntoComposeBox"}),r}}}class ee{constructor(e){a(this,"logger");this.logger=e}async launchWebAuthFlow(e){try{const r=await chrome.identity.launchWebAuthFlow(e);if(!r)throw new Error("Authentication was cancelled or failed");return r}catch(r){throw this.logger.error("Error launching web auth flow",r,{sourceFile:"src/platforms/chrome/ChromeIdentityProvider.ts",sourceFunction:"launchWebAuthFlow"}),r}}async initiateOAuth(e,r){return this.launchWebAuthFlow({url:e,interactive:!0})}}const re="CandleLogsDB",oe=1,y="logs",te=5e3,se=500,k={ERROR:1,WARN:2,INFO:3,DEBUG:4};let F=null;function S(){return F||(F=new Promise((n,e)=>{console.log("[Logger] Initializing IndexedDB...");const r=indexedDB.open(re,oe);r.onupgradeneeded=o=>{console.log("[Logger] IndexedDB upgrade needed.");const t=o.target.result;if(!t.objectStoreNames.contains(y)){console.log(`[Logger] Creating object store: ${y}`);const s=t.createObjectStore(y,{keyPath:"id",autoIncrement:!0});console.log("[Logger] Creating indexes: timestamp, level, chromeContext"),s.createIndex("timestamp","timestamp",{unique:!1}),s.createIndex("level","level",{unique:!1}),s.createIndex("chromeContext","chromeContext",{unique:!1})}},r.onsuccess=o=>{console.log("[Logger] IndexedDB initialized successfully."),n(o.target.result)},r.onerror=o=>{console.error("[Logger] IndexedDB initialization failed:",o.target.error),F=null,e(o.target.error)},r.onblocked=()=>{console.warn("[Logger] IndexedDB initialization blocked. Close other tabs using the database.")}}),F)}S().catch(n=>console.error("[Logger] Initial DB connection failed:",n));const g=class g{constructor(e){a(this,"context");a(this,"minLevel","INFO");this.context=e||"unknown"}async writeLog(e,r,o,t){if(k[e]>k[this.minLevel])return;const s=(o==null?void 0:o.sourceFile)||"unknown",i=o==null?void 0:o.sourceFunction;let c;t&&(t instanceof Error?c={name:t.name,message:t.message,stack:t.stack}:c=t);const{sourceFile:m,sourceFunction:h,...d}=o||{},l={...c?{error:c}:{},...d},u={timestamp:new Date().toISOString(),level:e,message:r,chromeContext:this.context,sourceFile:s,...i&&{sourceFunction:i},details:Object.keys(l).length>0?l:void 0};try{const E=(await S()).transaction(y,"readwrite"),b=E.objectStore(y).add(u);return new Promise((A,L)=>{b.onsuccess=()=>{A()},b.onerror=w=>{console.error("[Logger] Failed to write log to IndexedDB:",w.target.error,u),L(w.target.error)},E.onerror=w=>{console.error("[Logger] Transaction error writing log:",w.target.error,u),L(w.target.error)},E.onabort=w=>{console.warn("[Logger] Transaction aborted writing log:",w.target.error,u),L(new Error("Transaction aborted"))}})}catch(f){throw console.error("[Logger] Error obtaining DB or starting transaction:",f,u),f}}static async _cleanupOldLogs(){if(this._isCleaning){console.info("[Logger] Cleanup already in progress, skipping.");return}console.info("[Logger] Starting log cleanup check..."),this._isCleaning=!0;try{const r=(await S()).transaction(y,"readwrite"),o=r.objectStore(y),t=o.count(),s=await new Promise((h,d)=>{t.onsuccess=()=>h(t.result),t.onerror=l=>{console.error("[Logger] Failed to count logs for cleanup:",l.target.error),d(l.target.error)}});if(s<=this.MAX_LOG_ENTRIES){console.info(`[Logger] Log count (${s}) within limit (${this.MAX_LOG_ENTRIES}). No cleanup needed.`);return}let i=s-this.MAX_LOG_ENTRIES;console.warn(`[Logger] Log count (${s}) exceeds limit (${this.MAX_LOG_ENTRIES}). Deleting ${i} oldest logs.`);const c=o.openCursor();let m=0;await new Promise((h,d)=>{c.onsuccess=l=>{const u=l.target.result;if(u&&i>0){const f=u.delete();f.onsuccess=()=>{m++,i--,i>0?u.continue():h()},f.onerror=E=>{console.error("[Logger] Error deleting log entry during cleanup:",E.target.error,"Key:",u.primaryKey),u.continue()}}else h()},c.onerror=l=>{console.error("[Logger] Error opening cursor for cleanup:",l.target.error),d(l.target.error)}}),await new Promise((h,d)=>{r.oncomplete=()=>{console.info(`[Logger] Log cleanup finished. Deleted ${m} entries.`),h()},r.onerror=l=>{console.error("[Logger] Transaction error during cleanup:",l.target.error),d(l.target.error)},r.onabort=l=>{console.warn("[Logger] Transaction aborted during cleanup:",l.target.error),d(new Error("Cleanup transaction aborted"))}})}catch(e){console.error("[Logger] Error during log cleanup process:",e)}finally{this._isCleaning=!1,console.info("[Logger] Log cleanup check finished.")}}_triggerCleanupCheck(){if(g._writeCount++,g._writeCount>=g.CLEANUP_TRIGGER_COUNT&&!g._isCleaning){const e=g._writeCount;g._writeCount=0,console.info(`[Logger] Write count reached ${e}. Triggering background cleanup.`),g._cleanupOldLogs().catch(r=>{console.error("[Logger] Background cleanup process failed:",r)})}}async debug(e,r){try{await this.writeLog("DEBUG",e,r),this._triggerCleanupCheck()}catch{}}async info(e,r){try{await this.writeLog("INFO",e,r),this._triggerCleanupCheck()}catch{}}async warn(e,r){try{await this.writeLog("WARN",e,r),this._triggerCleanupCheck()}catch{}}async error(e,r,o){try{await this.writeLog("ERROR",e,o,r),this._triggerCleanupCheck()}catch{}}};a(g,"_writeCount",0),a(g,"_isCleaning",!1),a(g,"MAX_LOG_ENTRIES",te),a(g,"CLEANUP_TRIGGER_COUNT",se);let P=g;class ne{constructor(e){a(this,"logger");this.logger=new P(e)}async debug(e,r){return this.logger.debug(e,r)}async info(e,r){return this.logger.info(e,r)}async warn(e,r){return this.logger.warn(e,r)}async error(e,r,o){return this.logger.error(e,r,o)}setMinLevel(e){console.warn("[ChromeLoggingProvider] setMinLevel not yet implemented - using hardcoded INFO level")}getMinLevel(){return"INFO"}}function he(){const n=new ne("background");return{storage:new $(n),data:new U(n),auth:new H(n),messaging:new X(n),lifecycle:new Q(n),tabs:new Y(n),contentScript:new Z(n),identity:new ee(n),logging:n}}export{H as ChromeAuthProvider,Z as ChromeContentScriptProvider,U as ChromeDataProvider,ee as ChromeIdentityProvider,Q as ChromeLifecycleProvider,X as ChromeMessagingProvider,$ as ChromeStorageProvider,Y as ChromeTabsProvider,he as createChromeServices};
